---
title: "Spatial Statistics Final Project"
author: "Brusco, Bianca; Wang, Hongting; Yang, Lingfeng"
date: "9/28/2018"
output: pdf_document
---

    ```{r setup, include = FALSE, warning = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE, tidy = TRUE)
    library(ggplot2)
    library(lattice)
    library(spdep)
    library(RColorBrewer)
    library(classInt)
    library(rgdal)
    library(formatR)
    library(sm)
    library(tidyverse)
    library(revgeo)
    library(ggmap)
    library(sp)
    
    #snippet to override r-chunk fonts.
    def.chunk.hook  <- knitr::knit_hooks$get("chunk")
    knitr::knit_hooks$set(chunk = function(x, options) {
       x <- def.chunk.hook(x, options)
       ifelse(options$size != "normalsize", paste0("\\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
    })
    ```

#1. Importing and Cleaning data
##A. Importing data
(i). NYC Stop & Frisk data
(ii). Housing value panel data
```{r init-1,size="tiny",warning=FALSE,message=FALSE}
# Housing value
hvraw <- read.csv("data/Trimmed_home_value.csv", header = T)

# Stop & Frisk
load("data/sqf.RData")
#stops2013 <- subset(stops,year==2013)
#stops2013[1:3,c("date","precinct","suspected.crime","suspect.race","found.weapon")]
```

##B. Cleaning data
###(1). Housing Value
```{r}
# select relevant date range for housing value, filter out other cities
hv <- hvraw %>% filter(City == "New York") %>% select(RegionName, CountyName, X2005.12:X2014.01) %>% arrange(RegionName)
```

###(2). Stop & Frisk

https://www.mapdevelopers.com/geocode_bounding_box.php
For geographical boundaries of NYC.
North Latitude: 40.917577 South Latitude: 40.477399 East Longitude: -73.700272 West Longitude: -74.259090

```{r}
# filter out NAs for lon and lat, 1303 NAs and 47 "1900-12-31" for date, then select columns of interest, sorted in chronological order
sf <- stops %>% filter(lat > 40.2 & !is.na(lat) & lat < 41) %>% filter(date >= "2006-01-01" & date <= "2013-12-31") %>% select(year, date, time, precinct, suspected.crime, frisked, suspect.race, found.weapon, lat, lon) %>% arrange(date, time)

```

###(3). shapefiles for zip code bounds and NYC
```{r, echo = F}
# zip code shape file
zipraw <- readOGR("data/zip_code/ZIP_CODE_040114.shp")
nyc <- readOGR("data/Borough_Boundaries/geo_export_5e515234-1937-40b5-b942-1ef10ea3ea45.shp")

# change projection method to lon/lat
zipbd <-  spTransform(zipraw, CRS("+proj=longlat +ellps=WGS84 +no_defs"))

# test
plot(zipbd, lwd = 0.4)
points(sf$lon[1:10000], sf$lat[1:10000], pch = ".", cex = 2, col = sf[1:10000, ]$suspect.race)
```

###(4). Add zip code field to Stop & Frisk based on coordinates
```{r}
# Convert lon/lat into zip code, 300/min -> 18,000/hr -> 432,000/day, 9.15 day LOL
#Sys.time()
#x <- rep(0, 20)
#for (i in 1:20) {
#  x[i] <- as.numeric(revgeo(sf$lon[i], sf$lat[i], output = "hash", item = "zip"))
#}
#Sys.time()

# experimenting with reversing geo code
# update: IT WORKS! 500,000/14s -> takes around 110s to run the whole thing
#Sys.time()
#coord1 <- cbind(sf$lon[1:500000], sf$lat[1:500000])
#points <- SpatialPoints(coord1, CRS("+proj=longlat +ellps=WGS84 +no_defs"))
#y <- over(points, zipbd)
#summary(y)
#Sys.time()
#

coord1 <- cbind(sf$lon, sf$lat)
points <- SpatialPoints(coord1, CRS("+proj=longlat +ellps=WGS84 +no_defs"))
reversezip <- over(points, zipbd)
```
There are 1147 missing values, to further inspect the patterns, the following plot is created

```{r}
plot(zipbd, border = "green", lwd = 0.2)
points(sf$lon[which(is.na(reversezip$ZIPCODE))], sf$lat[which(is.na(reversezip$ZIPCODE))], pch = ".", cex = 2.5, col = "red")
```
It appears that all the missing values lie right on the boundaries. To fix this, we will find 8 surrounding points (all of whom of equal distance to the original point), from north going clockwise. We will then get the zipcode for all those 8 points and exclude NAs before taking a majority vote. Finally, we use the majority vote result to impute the NAs.

**function for matching boundary points**
```{r}
# The distance from the original point is about 370 ft.
zipcorrect <- function(lon, lat, shp) {
  revzip <- rep(NA, length(lon))
  for (i in 1:length(lon)) {
    # starting from north, rotating clockwise for the 8 sample points
    samp.lon <- c(lon[i], lon[i] + 0.001, lon[i] + 0.0014, lon[i] + 0.001, lon[i], lon[i] - 0.001, lon[i] - 0.0014, lon[i] - 0.001)
    samp.lat <- c(lat[i] + 0.0014, lat[i] + 0.001, lat[i], lat[i] - 0.001, lat[i] - 0.0014, lat[i] - 0.001, lat[i], lat[i] + 0.001)
    
    samp.coord <- cbind(samp.lon, samp.lat)
    
    samp.points <- SpatialPoints(samp.coord, CRS("+proj=longlat +ellps=WGS84 +no_defs"))
    
    samp.zip <- as.character(over(samp.points, shp)$ZIPCODE)
    shortzip <- samp.zip[which(!is.na(samp.zip))]
    
    revzip[i] <- shortzip[which.max(tabulate(match(shortzip, unique(shortzip))))]
  }
  return(revzip)
}
```

**Matching boundary points to zipcode**
```{r}
zipmiss <- sf[which(is.na(reversezip$ZIPCODE)), c(10, 9)]
Sys.time()
imputedzip <- zipcorrect(zipmiss$lon, zipmiss$lat, zipbd)
Sys.time()
# 2m32s, 1m58s
```

**Append zipcode and zipcode related fields to Stop & Frisk**
```{r}
sf$zip <- as.character(reversezip$ZIPCODE)
sf$zip[which(is.na(sf$zip))] <- imputedzip
sum(is.na(sf$zip))
```

```{r}
plot(zipbd, border = "red", lwd = 0.2)
points(sf$lon[which(sf$zip == "11232")], sf$lat[which(sf$zip == "11232")], pch = ".", cex = 1, col = sf$year)

plot(zipbd, border = "white", lwd = 0.5, col = zipbd@data$CTY_FIPS)
plot(zipbd, border = "white", lwd = 0.2, col = cm.colors(50, alpha = 0.9)[cut(zipbd@data$POPULATION, 50)])

plot(subset(zipbd, ZIPCODE == "10003"))
points(sf$lon[which(sf$zip == "10003")], sf$lat[which(sf$zip == "10003")], pch = ".", cex = 2, col = sf$year[which(sf$zip == "10003")])

plot(subset(zipbd, COUNTY == "New York"))
points(sf$lon[which(sf$zip == "10003")], sf$lat[which(sf$zip == "10003")], pch = ".", cex = 2, col = sf$year[which(sf$zip == "10003")])
```

##C. group stop and frisk data based zipcode
```{r}
str(zipbd@data)

```

#### NEED TO ADD ALL THE ATTRIBUTES FROM ZIPCODE TO THE DATA
```{r}
jointable <- zipbd@data %>% select(zip = ZIPCODE, po_name = PO_NAME, pop = POPULATION, area = AREA, county = COUNTY) %>% arrange(zip, desc(area))

zipbd@data[246:247, ]

plot(subset(zipbd, ZIPCODE == "10004"))

zipbd@data[c(107, 110, 114, 115), ]
```
Within the jointable, there is one duplicate record of zipcode 10047. There are other regions with multiple polygons associated with one zip code (10004 for instance). For these cases, we aggregate the land area and take any one of the population entry. It is cleaned in the following chunk.

```{r}
jtclean <- jointable[!duplicated(jointable), ]
jtclean <- jtclean %>% group_by(zip) %>% summarize(po_name = first(po_name), pop = first(pop), area = sum(area), county = first(county))

jtclean$zip <- as.character(jtclean$zip)
jtclean$county <- as.character(jtclean$county)

jtclean$county[which(jtclean$county == "New York")] <- "Manhattan"
jtclean$county[which(jtclean$county == "Richmond")] <- "Staten Island"
jtclean$county[which(jtclean$county == "Kings")] <- "Brooklyn"
colnames(jtclean)[5] <- "borough"
```


```{r}
sf_large <- left_join(sf, jtclean)
```




